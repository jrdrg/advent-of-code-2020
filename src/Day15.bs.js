// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var $$Array = require("bs-platform/lib/js/array.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Belt_MapInt = require("bs-platform/lib/js/belt_MapInt.js");
var Caml_format = require("bs-platform/lib/js/caml_format.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");

var inputStr = "0,8,15,2,12,1,4";

function parseInput(input) {
  return $$Array.to_list($$Array.map(Caml_format.caml_int_of_string, input.split(",")));
}

function turn(_$staropt$star, _$staropt$star$1, targetTurn, _$staropt$star$2, _numbers) {
  while(true) {
    var numbers = _numbers;
    var $staropt$star = _$staropt$star$2;
    var $staropt$star$1 = _$staropt$star$1;
    var $staropt$star$2 = _$staropt$star;
    var counts = $staropt$star$2 !== undefined ? Caml_option.valFromOption($staropt$star$2) : Belt_MapInt.fromArray(/* array */[]);
    var current = $staropt$star$1 !== undefined ? $staropt$star$1 : 1;
    var lastSpoken = $staropt$star !== undefined ? $staropt$star : 0;
    var InvalidNumbers = Caml_exceptions.create("InvalidNumbers");
    if (numbers) {
      var head = numbers[0];
      var match;
      if (current <= List.length(numbers)) {
        match = /* tuple */[
          Pervasives.$at(numbers[1], /* :: */[
                head,
                /* [] */0
              ]),
          head
        ];
      } else {
        var match$1 = Belt_MapInt.get(counts, lastSpoken);
        var updatedCounts;
        if (match$1 !== undefined) {
          var x = match$1;
          if (x) {
            var match$2 = x[1];
            updatedCounts = match$2 ? x[0] - match$2[0] | 0 : 0;
          } else {
            console.log("?????", $$Array.of_list(x), head);
            throw InvalidNumbers;
          }
        } else {
          updatedCounts = 0;
        }
        match = /* tuple */[
          numbers,
          updatedCounts
        ];
      }
      var spoken = match[1];
      if (current === targetTurn) {
        return spoken;
      } else {
        var counts$1 = Belt_MapInt.update(counts, spoken, (function(current){
            return function (v) {
              if (v !== undefined) {
                return /* :: */[
                        current,
                        v
                      ];
              } else {
                return /* :: */[
                        current,
                        /* [] */0
                      ];
              }
            }
            }(current)));
        _numbers = match[0];
        _$staropt$star$2 = spoken;
        _$staropt$star$1 = current + 1 | 0;
        _$staropt$star = Caml_option.some(counts$1);
        continue ;
      }
    } else {
      throw InvalidNumbers;
    }
  };
}

function day1(param) {
  return (function (eta) {
              return turn(undefined, undefined, 2020, undefined, eta);
            })(parseInput(inputStr));
}

console.log("Day 1:", day1(/* () */0));

function day2(param) {
  return (function (eta) {
              return turn(undefined, undefined, 30000000, undefined, eta);
            })(parseInput(inputStr));
}

console.log("Day 2:", day2(/* () */0));

var exampleStr = "0,3,6";

exports.exampleStr = exampleStr;
exports.inputStr = inputStr;
exports.parseInput = parseInput;
exports.turn = turn;
exports.day1 = day1;
exports.day2 = day2;
/*  Not a pure module */
